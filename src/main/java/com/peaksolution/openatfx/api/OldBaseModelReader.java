package com.peaksolution.openatfx.api;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.asam.ods.ErrorCode;
import org.asam.ods.RelationRange;
import org.asam.ods.RelationType;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import com.peaksolution.openatfx.util.ODSHelper;


public class OldBaseModelReader implements BaseModelReader {

    private final Collection<String> commonMandatoryAttributeNames = Arrays.asList("id", "name");
    private final Collection<String> commonAutogeneratedAttributeNames = Arrays.asList("id", "ao_created",
                                                                                       "ao_created_by",
                                                                                       "ao_last_modified",
                                                                                       "ao_last_modified_by");

    /**
     * @param baseElementName
     * @return
     */
    private Set<String> getMandatoryAttributeNames(String baseElementName) {
        Set<String> mandatoryAttributeNames = new HashSet<>();
        mandatoryAttributeNames.addAll(commonMandatoryAttributeNames);
        if ("AoAttributeMap".equalsIgnoreCase(baseElementName)) {
            mandatoryAttributeNames.add("attribute_name");
            mandatoryAttributeNames.add("alias_names");
        } else if ("AoMimetypeMap".equalsIgnoreCase(baseElementName)) {
            mandatoryAttributeNames.add("ao_list");
        } else if ("AoParameter".equalsIgnoreCase(baseElementName)) {
            mandatoryAttributeNames.add("parameter_datatype");
            mandatoryAttributeNames.add("pvalue");
        } else if ("AoMeasurementQuantity".equalsIgnoreCase(baseElementName)) {
            mandatoryAttributeNames.add("datatype");
        } else if ("AoSubmatrix".equalsIgnoreCase(baseElementName)) {
            mandatoryAttributeNames.add("number_of_rows");
        } else if ("AoFile".equalsIgnoreCase(baseElementName)) {
            mandatoryAttributeNames.add("ao_location");
            mandatoryAttributeNames.add("ao_size");
        } else if ("AoExternalComponent".equalsIgnoreCase(baseElementName)) {
            mandatoryAttributeNames.add("component_length");
            mandatoryAttributeNames.add("filename_url");
            mandatoryAttributeNames.add("value_type");
            mandatoryAttributeNames.add("start_offset");
            mandatoryAttributeNames.add("block_size");
            mandatoryAttributeNames.add("valuesperblock");
            mandatoryAttributeNames.add("value_offset");
        } else if ("AoLocalColumn".equalsIgnoreCase(baseElementName)) {
            mandatoryAttributeNames.add("independent");
            mandatoryAttributeNames.add("values");
        } else if ("AoUnit".equalsIgnoreCase(baseElementName)) {
            mandatoryAttributeNames.add("factor");
            mandatoryAttributeNames.add("offset");
        } else if ("AoPhysicalDimension".equalsIgnoreCase(baseElementName)) {
            mandatoryAttributeNames.add("length_exp");
            mandatoryAttributeNames.add("mass_exp");
            mandatoryAttributeNames.add("time_exp");
            mandatoryAttributeNames.add("current_exp");
            mandatoryAttributeNames.add("temperature_exp");
            mandatoryAttributeNames.add("molar_amount_exp");
            mandatoryAttributeNames.add("luminous_intensity_exp");
        } else if ("AoUser".equalsIgnoreCase(baseElementName)) {
            mandatoryAttributeNames.add("password");
        } else if ("AoUserGroup".equalsIgnoreCase(baseElementName)) {
            mandatoryAttributeNames.add("superuser_flag");
        }
        return mandatoryAttributeNames;
    }
    
    /**
     * @param baseElementName
     * @return
     */
    private Set<String> getAutogeneratedAttributeNames(String baseElementName) {
        Set<String> autogeneratedAttributeNames = new HashSet<>();
        autogeneratedAttributeNames.addAll(commonAutogeneratedAttributeNames);
        if ("AoMeasurement".equalsIgnoreCase(baseElementName)) {
            autogeneratedAttributeNames.add("ao_values_accessed");
            autogeneratedAttributeNames.add("ao_values_accessed_by");
            autogeneratedAttributeNames.add("ao_values_modified");
            autogeneratedAttributeNames.add("ao_values_modified_by");
            autogeneratedAttributeNames.add("ao_storagetype");
            autogeneratedAttributeNames.add("ao_mea_size");
        } else if ("AoFile".equalsIgnoreCase(baseElementName)) {
            autogeneratedAttributeNames.add("ao_size");
        }
        return autogeneratedAttributeNames;
    }
    
    /**
     * @param baseElementName
     * @return
     */
    private Set<String> getMandatoryRelationNames(String baseElementName) {
        Set<String> mandatoryRelationNames = new HashSet<>();
        if ("AoNameMap".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("attribute_mapping");
            mandatoryRelationNames.add("environment");
        } else if ("AoAttributeMap".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("name_mapping");
        } else if ("AoParameter".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("parameter_set");
        } else if ("AoParameterSet".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("parameters");
        } else if ("AoTest".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("children");
        } else if ("AoSubTest".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("children");
            mandatoryRelationNames.add("parent_test");
        } else if ("AoMeasurement".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("test");
            mandatoryRelationNames.add("measurement_quantities");
            mandatoryRelationNames.add("submatrices");
        } else if ("AoMeasurementQuantity".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("local_columns");
            mandatoryRelationNames.add("quantity");
            mandatoryRelationNames.add("unit");
            mandatoryRelationNames.add("measurement");
        } else if ("AoSubmatrix".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("local_columns");
            mandatoryRelationNames.add("measurement");
        } else if ("AoExternalComponent".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("local_column");
        } else if ("AoLocalColumn".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("submatrix");
            mandatoryRelationNames.add("measurement_quantity");
        } else if ("AoQuantity".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("measurement_quantities");
        } else if ("AoUnit".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("phys_dimension");
            mandatoryRelationNames.add("measurement_quantities");
        } else if ("AoQuantityGroup".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("quantities");
        } else if ("AoUnitGroup".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("units");
        } else if ("AoUser".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("groups");
        } else if ("AoUserGroup".equalsIgnoreCase(baseElementName)) {
            mandatoryRelationNames.add("users");
        }
        return mandatoryRelationNames;
    }
    
    public AtfxBaseModel getBaseModel(String baseModelVersion) {
        try {
            // parse XML
            InputStream in = OldBaseModelReader.class.getResourceAsStream(baseModelVersion + ".xml");
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse(in);
            return parseBaseStructure(doc);
        } catch (ParserConfigurationException | SAXException | IOException e) {
            throw new OpenAtfxException(ErrorCode.AO_UNKNOWN_ERROR, e.getMessage());
        }
    }

    /**
     * Parse the base structure from given XML document.
     * 
     * @param doc The XML document.
     * @return The base structure.
     * @throws OpenAtfxException Error creating base structure.
     */
    private AtfxBaseModel parseBaseStructure(Document doc) {
        Element rootElement = doc.getDocumentElement();
        String version = rootElement.getAttribute("version");
        Map<String, EnumerationDefinition> enumDefMap = parseEnumerationDefinitions(rootElement);
        Map<String, AtfxBaseElement> baseElemMap = parseBaseElements(enumDefMap, rootElement);

        AtfxBaseModel baseModel = new AtfxBaseModel(version);
        baseModel.addBaseEnumerations(enumDefMap.values());
        for (AtfxBaseElement baseElement : baseElemMap.values()) {
            baseModel.addBaseElement(baseElement);
        }
        parseBaseRelations(baseElemMap, rootElement);
        return baseModel;
    }

    /**
     * Parse the enumeration definitions from the XML document.
     * 
     * @param rootElement The root XML element.
     * @return map of enumeration definitions.
     */
    private Map<String, EnumerationDefinition> parseEnumerationDefinitions(Element rootElement) {
        Map<String, EnumerationDefinition> map = new HashMap<>();

        NodeList nodeList = rootElement.getElementsByTagName("EnumerationDefinition");
        for (int i = 0; i < nodeList.getLength(); i++) {
            Element enumDefElem = (Element) nodeList.item(i);
            int index = Integer.parseInt(enumDefElem.getAttribute("index"));
            String name = enumDefElem.getAttribute("name");
            AtfxEnumeration enumDef = new AtfxEnumeration(index, name);

            // parse items
            NodeList itemNodeList = enumDefElem.getElementsByTagName("EnumerationItem");
            for (int x = 0; x < itemNodeList.getLength(); x++) {
                Element itemElem = (Element) itemNodeList.item(x);
                int item = Integer.parseInt(itemElem.getAttribute("item"));
                String itemName = itemElem.getAttribute("name");
                enumDef.addItem(item, itemName);
            }

            map.put(name, enumDef);
        }

        return map;
    }

    /**
     * Parse the enumeration definitions from the XML document.
     * 
     * @param enumDefs Map of enumeration definitions.
     * @param rootElement The root XML element.
     * @return map of enumeration definitions.
     * @throws OpenAtfxException Error parsing base elements.
     */
    private Map<String, AtfxBaseElement> parseBaseElements(Map<String, EnumerationDefinition> enumDefs,
            Element rootElement) {
        Map<String, AtfxBaseElement> map = new HashMap<>();

        NodeList nodeList = rootElement.getElementsByTagName("BaseElement");
        for (int i = 0; i < nodeList.getLength(); i++) {
            Element baseElementElem = (Element) nodeList.item(i);
            String type = baseElementElem.getAttribute("type");
            boolean topLevel = Boolean.parseBoolean(baseElementElem.getAttribute("topLevel"));
            AtfxBaseElement baseElement = new AtfxBaseElement(type, topLevel);
            for (BaseAttribute baseAttr : parseBaseAttributes(enumDefs, baseElement, baseElementElem)) {
                baseElement.addBaseAttribute(baseAttr);
            }
            map.put(type, baseElement);
        }

        return map;
    }

    /**
     * Parse the base attributes of an base element from the XML document.
     * 
     * @param enumDefs Map of enumeration definitions.
     * @param baseElement The base element.
     * @param baseElementElem The XML element of the base element.
     * @return Array of base attributes.
     * @throws OpenAtfxException Error parsing base elements.
     */
    private BaseAttribute[] parseBaseAttributes(Map<String, EnumerationDefinition> enumDefs,
            BaseElement baseElement, Element baseElementElem) {
        List<BaseAttribute> list = new ArrayList<>();

        Set<String> mandatoryAttributes = getMandatoryAttributeNames(baseElement.getType());
        Set<String> autogeneratedAttributes = getAutogeneratedAttributeNames(baseElement.getType());
        NodeList nodeList = baseElementElem.getElementsByTagName("BaseAttribute");
        for (int i = 0; i < nodeList.getLength(); i++) {
            Element baseAttributeElem = (Element) nodeList.item(i);
            String name = baseAttributeElem.getAttribute("name");
            DataType dataType = DataType.fromString(baseAttributeElem.getAttribute("dataType"));
            boolean obligatory = Boolean.parseBoolean(baseAttributeElem.getAttribute("obligatory"));
            boolean unique = Boolean.parseBoolean(baseAttributeElem.getAttribute("unique"));
            EnumerationDefinition enumDef = null;
            if (dataType == DataType.DT_ENUM || dataType == DataType.DS_ENUM) {
                String enumDefName = baseAttributeElem.getAttribute("enumerationDefinition");
                enumDef = enumDefs.get(enumDefName);
                if (enumDef == null) {
                    throw new OpenAtfxException(ErrorCode.AO_NOT_FOUND,
                                                "Enumeration definition '" + enumDefName + "' not found");
                }
            }
            
            boolean mandatory = mandatoryAttributes.contains(name.toLowerCase());
            boolean autogenerated = autogeneratedAttributes.contains(name.toLowerCase());
            
            BaseAttribute baseAttribute = new AtfxBaseAttribute(name, dataType, mandatory, obligatory, unique, autogenerated, baseElement,
                                                                enumDef == null ? null : enumDef.getName());
            list.add(baseAttribute);
        }

        return list.toArray(new BaseAttribute[0]);
    }

    /**
     * Parse all base relations from given root element.
     * 
     * @param baseElems The base elements.
     * @param rootElement The root XML element.
     * @return Array of base relations.
     * @throws OpenATfxException Error parsing base relations.
     */
    private BaseRelation[] parseBaseRelations(Map<String, AtfxBaseElement> baseElems, Element rootElement) {
        List<BaseAttribute> list = new ArrayList<>();
        
        BaseElement currentBaseElement = null;
        Set<String> currentElementsMandatoryRelNames = getMandatoryRelationNames(null);
        NodeList nodeList = rootElement.getElementsByTagName("BaseRelation");
        for (int i = 0; i < nodeList.getLength(); i++) {
            Element baseRelationElem = (Element) nodeList.item(i);

            BaseElement elem1 = baseElems.get(baseRelationElem.getAttribute("elem1"));
            BaseElement elem2 = baseElems.get(baseRelationElem.getAttribute("elem2"));
            
            String relationName = baseRelationElem.getAttribute("relationName");
            String inverseRelationName = baseRelationElem.getAttribute("inverseRelationName");
            
            if (!elem1.equals(currentBaseElement)) {
                currentBaseElement = elem1;
                currentElementsMandatoryRelNames = getMandatoryRelationNames(elem1.getType());
            }
            boolean mandatory = currentElementsMandatoryRelNames.contains(relationName.toLowerCase());

            RelationRange relationRange = new RelationRange();
            relationRange.min = ODSHelper.string2relRange(baseRelationElem.getAttribute("relationRangeMin"));
            relationRange.max = ODSHelper.string2relRange(baseRelationElem.getAttribute("relationRangeMax"));
            RelationRange inverseRelationRange = new RelationRange();
            inverseRelationRange.min = ODSHelper.string2relRange(baseRelationElem.getAttribute("inverseRelationRangeMin"));
            inverseRelationRange.max = ODSHelper.string2relRange(baseRelationElem.getAttribute("inverseRelationRangeMax"));

            Relationship relationship = Relationship.valueOf(baseRelationElem.getAttribute("relationship"));
            Relationship inverseRelationship = Relationship.valueOf(baseRelationElem.getAttribute("inverseRelationship"));

            RelationType relationType = ODSHelper.string2relationType(baseRelationElem.getAttribute("relationType"));

            Collection<BaseElement> elements2 = new ArrayList<>();
            elements2.add(elem2);
            BaseRelation baseRelation = new AtfxBaseRelation(elem1, elements2, relationName,
                                                             inverseRelationName, mandatory, relationRange,
                                                             inverseRelationRange, relationship,
                                                             inverseRelationship, relationType);
            elem1.addBaseRelation(baseRelation);
        }

        return list.toArray(new BaseRelation[0]);
    }
}
